\section{Introduction}~\label{sec:introduction}

% Code smells are important
% Manual checking is error-prone
% Automated tools are needed

Code smells are a series of code-design-related concerns that decrease
readability \cite{5741260,SANTOS2018450} and maintainability
\cite{6392174,6405287} of software projects, ultimately limiting opportunities
for future maintenance \cite{Fowler_Beck}. Even though developers acknowledge
the negative influence of code smells on project quality~\cite{developersCare},
manual smell detection remains a error-prone and resource-consuming process
\cite{DetectingDefectsInObject}. This necessitated the development of tools to
automate this process. Different code smell detection tools rely on various
detection strategies, such as abstract syntax tree (AST) analysis, machine
learning, and static analysis~\cite{ML}. Developers also use popular, yet
language-specific, smell detection tools (e.g., PMD \cite{PMD} and CheckStyle
\cite{CheckStyle}) in the continuous integration setup of open-source projects
like Apache Commons Lang \cite{ApacheCommonsLang} and Jenkins \cite{Jekins}.

% Multi-language projects are common
% Code smell detection is not commonly language-independent
% Maintaining multiple tools is a cumbersome task

One of the characteristics of modern software projects is the frequent use of
multiple programming languages \cite{723183}. The combination of programming
languages allows developers to mix and match the functionalities and libraries
that are best supported by specific programming language \cite{7476675}.
However, the complexity of multi-language software projects increases the
difficulty of project comprehension and maintenance \cite{7476675,
10.1109/SCAM.2012.11, 7396422}. Along with the complexity, the multi-language
software projects also introduce the pressing challenge of code smell
detection. Most of the existing code smell detection tools are designed to
detect code smells in a single programming language. Multi-language projects,
like Jenkins \cite{Jekins}, implement multiple detection tools in
multi-language software projects, thereby introducing the overhead of
configuring multiple code smell detection tools with various detection
approaches.

While few code smell detection tools are language-independent, most code smells
are. For example, Long Method, one of the most prevalent code smells
\cite{developersCare}, can exist in many programming languages. Due to the
language-independence of code smells, code smell detection tools also have the
potential to be language-independent. For instance, Van Emden and Moonen, the
creators of an early code smell detection tool, indicated that their detection
approach in Java had the potential to be applied to other programming languages
in the future \cite{1173068}. Furthermore, Abidi~\etal{} built a multi-language
design smells (i.e., anti-patterns and code smells) detection tool to detect 15
multi-language-specific design smells in system in combinations of Java and
C/C++ \cite{MultiLanguageCodeSmells,Fault-Prone}. A truly language-independent
smell detection tool would offer a unified detection experience for use in both
multi-language software projects and across many single-language projects.

% Cut: perhaps this is not needed as it slightly duplicates a prior point?

% It can also avoid the overhead of configuring multiple code smell detection
% tools with various detection approaches.

% Describe TreeNose tool and its features,
% making sure to mention that it is language-independent
% and that it is highly extensible due to Treesitter

Addressing this need, this paper presents a language-independent code smell
detection tool, called \texttt{TreeNose}, to detect 5 types of code smells ---
Complex Conditional, Long Class, Long Method, Long Message Chain, Long Parameter
List --- across multiple programming languages. \texttt{TreeNose} leverages
Treesitter \cite{treeSitter}, a general-purpose parser generator, to parse the
source code of multiple programming languages into an AST. Leveraging the
generated AST, \texttt{TreeNose} queries the nodes with detection rules to
detect targeted code smells with configurable thresholds. Since it builds on
Treesitter, \texttt{TreeNose} is highly extensible, allowing developers to add
new programming languages without rewriting its source code.

To evaluate the accuracy of \texttt{TreeNose}, we evaluated \texttt{TreeNose} on
9 open-source projects implemented in Java, JavaScript, or Python. We compared
the performance of \texttt{TreeNose} with the combination of 3 language-specific
code smell detection tools in a manual annotation study. We also conducted
evaluations on the characteristics of code smells in different programming
languages.

The key contributions of this paper are as follows:

\begin{enumerate}

    \item A language-independent code smell detector that detects 5 types of
        code smells across programming languages.

    \item An evaluation of \texttt{TreeNose} to evaluate its accuracy in
        multiple programming languages.

    \item An experiment to reveal the prevalence and distribution of code smells
        in different programming languages.

\end{enumerate}

Our results show that \texttt{TreeNose} achieved high precision of 92\% and F1
score of 0.94 in detecting selected code smells in target programming languages.
We also found that (1) Complex Conditional counts for 42\% of the total code
smells detected on average, which is the most common code smell in the selected
programming languages. (2) Programming languages have strong tendencies to have
specific code smells, such as JavaScript contains 3 times more Long Method than
other systems. (3) Multi-Language software projects have more evenly distributed
code smells than single-language software projects.
